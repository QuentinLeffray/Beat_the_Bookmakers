# -*- coding: utf-8 -*-
"""Projet ATP Data.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tsKmZvIRs-tb_pUe0rcfHTqgMEuu--Eh
"""

### EXPLORATION DE DONNEES

# Commented out IPython magic to ensure Python compatibility.
### Import des modules nécessaires

import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
# %matplotlib inline

from bokeh.plotting import figure, output_notebook, show
output_notebook()

sns.set_theme()

### Import des modules de préprocessing

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.preprocessing import OneHotEncoder

### Import des modèles de classifications à tester
from sklearn.linear_model import LogisticRegression
from sklearn.neighbors import KNeighborsClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn import tree
from sklearn.model_selection import GridSearchCV, StratifiedKFold, RepeatedStratifiedKFold, cross_val_score
from sklearn.svm import SVC

### Import du dataset

url = 'https://raw.githubusercontent.com/QuentinLeffray/Projet-ATP-Bookmakers/main/atp_data.csv'

df = pd.read_csv(url)

### Première visualisation des données du dataset
df['Date'] = pd.to_datetime(df['Date'])
df.info()
df.head()

### Contrôle des lignes en double, ici aucun doublon

df.duplicated().sum()

### Contrôle des valeurs manquantes

df.isna().sum().loc[lambda x: x> 0].sort_values(ascending = False)

### Homogénéisation des données par la suppression des lignes où nous ne detenons pas l'information de côte de la part des deux bookmakers 

df = df.dropna(axis = 0, how = 'all', subset = ['PSW'])
df = df.dropna(axis = 0, how = 'all', subset = ['B365W'])

### Remplacement des valeurs NaN des W/LSets par 0 car uniquement des matchs Walkover(sans match joué) et Retired (match commencé mais sans set terminé pour le gagnant). 1 exception pour un match terminé, marginal donc remplacé par 0

df['Wsets'] = df['Wsets'].fillna(0)
df['Lsets'] = df['Lsets'].fillna(0)

### Informations du DataFrame après traitement

df.info()

df.reset_index(drop=True, inplace=True)

df

### DATAVIZ

# Heatmap / Matrice de correlation

fig, ax = plt.subplots(figsize = (12,8))

sns.heatmap(df.corr(), ax = ax, cmap = 'coolwarm', annot = True);

### Création des colonnes permettant de savoir si un joueur ayant un meilleur ELO / Rang / Favori pour Pinnacle / Favori pour Bet365 gagne
df['ELO_Predicable_Win'] = (df['elo_winner'] - df['elo_loser']).apply(lambda x: True if  x > 0  else False)
df['Rank_Predicable_Win'] = (df['WRank'] - df['LRank']).apply(lambda x: True if  x < 0  else False)
df['Pinnacle_Predicable_Win'] = (df['PSW'] - df['PSL']).apply(lambda x: True if  x < 0  else False)
df['B365_Predicable_Win'] = (df['B365W'] - df['B365L']).apply(lambda x: True if  x < 0  else False)

### value_counts() pour chacune des variables crées, permettant de déterminer une certaine cohérence dans les données
display(df['ELO_Predicable_Win'].value_counts())
display(df['Rank_Predicable_Win'].value_counts())
display(df['Pinnacle_Predicable_Win'].value_counts())
display(df['B365_Predicable_Win'].value_counts())

### Création de la colonne permettant de visualiser des écarts standardisés pour réaliser les graphiques
df['ELO_Diff'] = df['elo_winner'] - df['elo_loser']

df['ELO_Diff_Gagnant'] = pd.cut(x = df['ELO_Diff'],
                                bins = [-1000, -500, -400, -300, -200, -100, 0, 100, 200, 300, 400, 500, 1000],
                                labels = ['-1000 / -500','-500 / - 400', '-400 / - 300', '-300 / -200', '-200 / -100', '-100 / 0', 
                                          '0 / 100', '100 / 200', '200 / 300', '300 / 400', '400 / 500', '500 / 1000'])

# Construction d'un subplot de VBar permettant de visualiser les résultats des colonnes créées auparavant

plt.figure(figsize = (20,14))

plt.subplot(221)
sns.countplot(df['ELO_Predicable_Win']);
plt.xlabel('Le joueur avec le plus haut ELO remporte le match');
plt.xticks([0, 1], ['Faux', 'Vrai']);
plt.ylabel('Nombre de matchs');
plt.title("Résultat en fonction de l'ELO");

plt.subplot(222)
sns.countplot(df['Rank_Predicable_Win']);
plt.xlabel('Le joueur avec le meilleur rang remporte le match');
plt.xticks([0, 1], ['Faux', 'Vrai']);
plt.ylabel('Nombre de matchs');
plt.title("Résultat en fonction du rang du joueur");

plt.subplot(223)
sns.countplot(df['Pinnacle_Predicable_Win']);
plt.xlabel('Le joueur avec la meilleure côte remporte le match');
plt.xticks([0, 1], ['Faux', 'Vrai']);
plt.ylabel('Nombre de matchs');
plt.title("Résultat en fonction du favori sur Pinnacle");

plt.subplot(224)
sns.countplot(df['B365_Predicable_Win']);
plt.xlabel('Le joueur avec la meilleure côte remporte le match');
plt.xticks([0, 1], ['Faux', 'Vrai']);
plt.ylabel('Nombre de matchs');
plt.title("Résultat en fonction du favori sur Bet365");

### Répartition des victoires en fonction de la différence d'ELO
plt.figure(figsize = (10,6))

sns.countplot(df['ELO_Predicable_Win'], hue = df['ELO_Diff_Gagnant']);
plt.legend(loc = 'center');
plt.xlabel("Différence d'ELO pour le gagnant du match");
plt.ylabel("Nombre de matchs");

### Vérification graphique de stratégie (Pari sur le mieux classé à l'ELO / Favori pour le bookmaker sur les deux bookmakers)

roi_favori_ps=100*(df.PSW[df['PSW']<df['PSL']].sum()-len(df))/len(df)
roi_meilleur_rang_ps=100*(df.PSW[df['elo_winner']>df['elo_loser']].sum()-len(df))/len(df)

roi_favori_365=100*(df.B365W[df['B365W']<df['B365L']].sum()-len(df))/len(df)
roi_meilleur_rang_365=100*(df.B365W[df['elo_winner']>df['elo_loser']].sum()-len(df))/len(df)

labels = ["Favori pour \n Pinnacle","Pari sur le mieux classé ELO \n Pinnacle", "Favori pour \n Bet365","Pari sur le mieux classé ELO \n Bet365 "]

p = figure(plot_height = 400, plot_width = 400, y_range = labels, x_range = (0,-10))

p.hbar(y = labels, 
       right = [roi_favori_ps, roi_meilleur_rang_ps, roi_favori_365, roi_meilleur_rang_365], 
       height = 0.9,
       color = ['orange', 'red', 'pink', 'purple',])

show(p)

# Calcul du ROI maximum possible
max_roi_ps = 100*(df.PSW.sum()-len(df))/len(df)
max_roi_365 = 100*(df.B365W.sum()-len(df))/len(df)

# Création du graphique
values = [max_roi_ps, max_roi_365]
labels = ["Pinnacle","Bet365"]
xaxis_label = "Bookmaker"
title = "Valeurs de ROI maximum possibles pour Pinnacle et Bet365"

plt.figure( figsize = (10,6))
plt.bar(labels, values)
plt.xlabel(xaxis_label)
plt.ylabel("ROI (%)")
plt.title(title)
plt.show()

### Stockage dans une variable de la proba_elo, transformée en %

proba_elo_en_pct = df['proba_elo']*100

### Instanciation de la figure Bokeh

p = figure(plot_width = 600, plot_height = 400, y_range = (0,1000), x_range = (50,100), title = "Probabilité de victoire en fonction de l'écart d'ELO du favori")

### Tracé de la droite

p.scatter(proba_elo_en_pct,                    
          df['ELO_Diff'],                         
          line_alpha = 0.6,
          line_color = "red",
          fill_alpha = 0) 

### Modification des différentes données du graphique

p.title.align = 'center'
p.xaxis.ticker = [50, 60, 70, 80, 90, 100]
p.xaxis.major_label_overrides = {50: '50%', 60: '60%', 70: '70%', 80: '80%', 90: '90%', 100: '100%'}

show(p)

### PRE-PROCESSING

# On réattribue les colonnes Winner/Loser au profit d'un J1/J2 pour enlever le biais de connaitre le résultat à l'avance

df['Joueur_1'] = np.where(np.random.rand(len(df)) > 0.5, df['Winner'], df['Loser'])
df['Joueur_2'] = np.where(df['Joueur_1'] == df['Winner'], df['Loser'], df['Winner'])

### ANONIMISATION DES DONNÉES

# Réaffectation de la côte à chaque joueur et non plus au couple Winner/Loser

df['PSJ1'] = np.where(df['Winner'] == df['Joueur_1'], df['PSW'], df['PSL'])
df['PSJ2'] = np.where(df['Winner'] == df['Joueur_1'], df['PSL'], df['PSW'])

# Réaffectation de l'ELO à chaque joueur et non plus au couple Winner/Loser

df['elo_J1'] = np.where(df['Winner'] == df['Joueur_1'], df['elo_winner'], df['elo_loser'])
df['elo_J2'] = np.where(df['Winner'] == df['Joueur_1'], df['elo_loser'], df['elo_winner'])

# Proba ELO pour chaque joueur

df['proba_elo_J1'] = np.where(df['Winner'] == df['Joueur_1'], df['proba_elo'], 1 - df['proba_elo'])
df['proba_elo_J2'] = np.where(df['Winner'] == df['Joueur_1'], 1 - df['proba_elo'], df['proba_elo'])

### CREATION DE VARIABLES EXPLICATIVES

# Créer les colonnes qui calcule le pourcentage de victoires pour chaque joueur

win= df['Winner'].value_counts()
matchs_played = df[['Winner', 'Loser']].stack().value_counts()

winrate = (win / matchs_played).round(2)

df['winrate_J1'] = df['Joueur_1'].map(winrate)
df['winrate_J2'] = df['Joueur_2'].map(winrate)

# Créer les colonnes qui calcule le pic ELO pour chaque joueur

maxima_elo = df.groupby('Loser')['elo_loser'].max()

df['max_elo_J1'] = df['Joueur_1'].map(maxima_elo)
df['max_elo_J2'] = df['Joueur_2'].map(maxima_elo)

df[['winrate_J1', 'winrate_J2']] = df[['winrate_J1', 'winrate_J2']].fillna(0) ### Suppression des valeurs nulles (ici par manque de données pour le calcul du winrate)
df[['max_elo_J1', 'max_elo_J2']] = df[['max_elo_J1', 'max_elo_J2']].fillna(1500)

df.info()

### CREATION DE LA TARGET

df['Target'] = np.where(df['Joueur_1'] == df['Winner'], 0, 1)

# On retire des colonnes pour alléger la base de données afin d'avoir un retour du modèle plus rapide

df = df.drop(['ATP', 'Comment', 'Location', 'Tournament', 'Series','Round', 'Best of', 'B365W', 'B365L', 'Wsets', 'Lsets', 'WRank', 
              'LRank', 'B365_Predicable_Win','Rank_Predicable_Win', 'ELO_Diff', 'ELO_Diff_Gagnant', 'ELO_Predicable_Win',
              'Pinnacle_Predicable_Win', 'Winner', 'Loser', 'Date', 'Court', 'PSW', 'PSL', 'elo_winner', 'elo_loser', 'proba_elo'],
               axis=1)

df

# Séparation du jeu de données en deux DataFrame (dont un pour sortir la cible)

feats = df.drop(['Target', 'Joueur_1', 'Joueur_2'], axis = 1)

target = df['Target']

# Séparation des dataframes afin d'avoir un jeu d'entrainement et un jeu de test

X_train, X_test, y_train, y_test = train_test_split(feats, target, test_size = 0.25, shuffle = False)

X_test.head()

# Standardisation des valeurs numériques

sc = StandardScaler()

col_num = ['PSJ1', 'PSJ2', 'elo_J1', 'elo_J2', 'proba_elo_J1', 'proba_elo_J2', 'winrate_J1', 'winrate_J2', 'max_elo_J1', 'max_elo_J2']

X_train[col_num] = sc.fit_transform(X_train[col_num])
X_test[col_num] = sc.transform(X_test[col_num])

#Encoding sur les variables explicatives/catégorielles (ici textuelles) avec un .replace

X_train['Surface'].replace(['Hard', 'Clay', 'Grass', 'Carpet'], [0, 1, 2, 3], inplace=True)
X_test['Surface'].replace(['Hard', 'Clay', 'Grass', 'Carpet'], [0, 1, 2, 3], inplace=True)

# Modèles à tester
lr = LogisticRegression()
knn = KNeighborsClassifier()
rf = RandomForestClassifier()
clftree = tree.DecisionTreeClassifier()

# Entraînement des modèles
lr.fit(X_train, y_train)
print("score du lr : {}".format(lr.score(X_test, y_test)))

knn.fit(X_train, y_train)
print("score du knn : {}".format(knn.score(X_test, y_test)))

rf.fit(X_train, y_train)
print("score du rf : {}".format(rf.score(X_test, y_test)))

clftree.fit(X_train, y_train)
print("score du clftree : {}".format(clftree.score(X_test, y_test)))

### Nous allons donc choisir la LogisticRegression qui obtient ici le meilleur score

from sklearn.linear_model import LogisticRegression

reglog = LogisticRegression()
reglog.fit(X_train, y_train)

print('Score sur ensemble train', reglog.score(X_train, y_train))
print('Score sur ensemble test', reglog.score(X_test, y_test))

from sklearn.metrics import classification_report

y_pred = reglog.predict(X_test)

display(pd.crosstab(y_test,y_pred, rownames=['Realité'], colnames=['Prédiction']))

print(classification_report(y_test, y_pred, ))

# définir les hyperparamètres à tester
param_grid = {'penalty': ['l1', 'l2'], 'C': [0.1, 1, 10]}

# définir le modèle
model = LogisticRegression(solver='liblinear')

# définir la grille de recherche
grid_search = GridSearchCV(model, param_grid, cv=4, n_jobs=-1, error_score='raise')

# ajuster la grille de recherche aux données
try:
    grid_search.fit(X_train, y_train)
except Exception as e:
    print('Error: ', e)

# afficher les meilleurs paramètres et score
print("Best parameters: ", grid_search.best_params_)
print("Best score: ", grid_search.best_score_)

y_test

def allocation_paris(base_cagnotte=0, mise_min=10, mise_max=1000, sureté=0.99):

    y_pred_proba = grid_search.predict_proba(X_test) 

    cagnotte = base_cagnotte
    
    mise_totale = 0
    
    for i, probas in enumerate(y_pred_proba):
        
        cotes_J1 = df['PSJ1'].loc[i+24257]
        cotes_J2 = df['PSJ2'].loc[i+24257]
                
        if probas[0]>sureté:
            if y_test.loc[i+24257]==0:
                print('parier {}€ sur victoire Joueur 1 -'.format(round(mise_min+(mise_max-mise_min)*(probas[0]-sureté)/(1-sureté))) ,
                      'cote à {} -'.format(cotes_J1),
                      'GAGNÉ - cagnotte : {}€'.format(cagnotte + round((mise_min+(mise_max-mise_min)*(probas[0]-sureté)/(1-sureté))*(cotes_J1))))
                cagnotte += round((mise_min+(mise_max-mise_min)*(probas[0]-sureté)/(1-sureté))*(cotes_J1))
            else:
                print('parier {}€ sur victoire Joueur 1 -'.format(round(mise_min+(mise_max-mise_min)*(probas[0]-sureté)/(1-sureté))) ,
                      'cote à {} -'.format(cotes_J1),
                      'PERDU - cagnotte : {}€'.format(cagnotte - round(mise_min+(mise_max-mise_min)*(probas[0]-sureté)/(1-sureté))))
                cagnotte -= round(mise_min+(mise_max-mise_min)*(probas[0]-sureté)/(1-sureté))
            mise_totale += round(mise_min+(mise_max-mise_min)*(probas[0]-sureté)/(1-sureté))
                
        if probas[1]>sureté:
            if y_test.loc[i+24257]==1:
                print('parier {}€ sur victoire Joueur 2 -'.format(round(mise_min+(mise_max-mise_min)*(probas[1]-sureté)/(1-sureté))) ,
                      'cote à {} -'.format(cotes_J2),
                      'GAGNÉ - cagnotte : {}€'.format(cagnotte + round((mise_min+(mise_max-mise_min)*(probas[1]-sureté)/(1-sureté))*(cotes_J2))))
                cagnotte += round((mise_min+(mise_max-mise_min)*(probas[1]-sureté)/(1-sureté))*(cotes_J2))
            else:
                print('parier {}€ sur victoire Joueur 2 -'.format(round(mise_min+(mise_max-mise_min)*(probas[1]-sureté)/(1-sureté))) ,
                      'cote à {} -'.format(cotes_J2),
                      'PERDU - cagnotte : {}€'.format(cagnotte - round(mise_min+(mise_max-mise_min)*(probas[1]-sureté)/(1-sureté))))
                cagnotte -= round(mise_min+(mise_max-mise_min)*(probas[1]-sureté)/(1-sureté))
            mise_totale += round(mise_min+(mise_max-mise_min)*(probas[1]-sureté)/(1-sureté))
                            
    print("La mise totale a été de ", mise_totale, '€')

allocation_paris()

plt.figure(figsize = (10,14))
pd.Series(grid_search.best_estimator_.coef_[0], X_test.columns).sort_values(ascending=False).plot(kind='barh');